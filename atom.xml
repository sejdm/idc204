<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Shane - RSS feed</title>
    <link href="http://blog.shane/atom.xml" rel="self" />
    <link href="http://blog.shane" />
    <id>http://blog.shane/atom.xml</id>
    <author>
        <name>Shane</name>
        <email>shane.dmello@gmail.com</email>
    </author>
    <updated>2020-03-16T00:00:00Z</updated>
    <entry>
    <title>Solutions to mid-semester 2</title>
    <link href="http://blog.shane/posts/2020-03-16-midsem2-solutions.html" />
    <id>http://blog.shane/posts/2020-03-16-midsem2-solutions.html</id>
    <published>2020-03-16T00:00:00Z</published>
    <updated>2020-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
<header>
<h1>Solutions to mid-semester 2</h1>
<p class="date"><strong>16 March, 2020</strong></p>
</header>

<section>
<h3 id="question-1">Question 1</h3>
<p><em>Consider the language over the alphabet <span class="math inline">\(\Sigma=\{a, b, c, d\}\)</span> recognized by the following non-deterministic finite state automaton.</em></p>
<p><img src="http://blog.shane/files/ndfa.png" /></p>
<h4 id="part-a">Part a)</h4>
<p><em>Find a regular expression that describes the language.</em></p>
<p><strong>Answer:</strong> <span class="math inline">\(ac^*d \cup b\)</span></p>
<p>The usual method of adding “empty” arrows is useful to shorten the proof that every regular language can be defined by a regular expression, but unnecessarily long in this situation. There are no arrows going into the initial state and no arrows coming out of the final state, and the loop is responsible for the <span class="math inline">\(c^*\)</span>.</p>
<h4 id="part-b">Part b)</h4>
<p><em>Convert the automaton to a deterministic automaton that recognizes the same language but which has at most one extra state.</em></p>
<p>Remember that in a deterministic automaton, one must have a unique new state for each state and <em>each</em> letter of the alphabet. The automaton is non-deterministic because some states do not have arrows corresponding to certain letters coming out it. Reading such a letter when it is in that state should make it die out. So all one needs to do is to add one “reject” state to which all such letters are redirected.</p>
<h4 id="part-c">Part c)</h4>
<p><em>Find a context free grammar that generates the language.</em></p>
<p>Since the language may be thought of as a union of two languages, we can use a variable to branch out, leading to the following rules:</p>
<ol type="1">
<li><span class="math display">\[S \to A \ |\  b\]</span> (The variable <span class="math inline">\(A\)</span> will take care of strings of the form <span class="math inline">\(ac^*d\)</span>, but the string may also be a single <span class="math inline">\(b\)</span>. Some of you added an extra variable <span class="math inline">\(B\)</span>, which then led to the terminal <span class="math inline">\(b\)</span>. That is fine, but not necessary in this case).</li>
<li><span class="math display">\[A \to aCd\]</span> (Only the <span class="math inline">\(C\)</span> is repeated, so we need an extra variable to take care of the repetition; the <span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> may be added immediately.</li>
<li><span class="math display">\[C \to cC \ |\ \epsilon\]</span> (The variable on the right hand side allows the C to be repeated indefinitely. When it needs to stop, one can use the empty string. Several variations here are also fine, including replacing the empty string with a single <span class="math inline">\(c\)</span> or <span class="math inline">\(C \to CC \ |\ c\)</span>).</li>
</ol>
<p>Some of you have done it by following the general algorithm to convert a finite state automaton recognizing a language into a context free grammar recognizing the same language. Then you would get a rule for each state. The method is longer than needed when applied to this case but more general and also perfectly fine.</p>
<h3 id="question-2">Question 2</h3>
<p>Find regular expressions to describe the following languages, each over the alphabet <span class="math inline">\(\{0, 1\}\)</span>.</p>
<h4 id="part-a-1">Part a)</h4>
<p><em>All strings except the string 10.</em></p>
<p><strong>Answer:</strong> <span class="math inline">\(\epsilon\cup \Sigma\cup \Sigma\Sigma\Sigma^* \cup 00 \cup 01 \cup 11\)</span></p>
<p>Note that this is a complement of a finite (in fact singleton) language. So strings that avoid certain fixed lengths (in this case, 2) are definitely in the language, and the rest are finite in number. Therefore, the regular expression may involve <span class="math inline">\(\epsilon \cup \Sigma\cup \Sigma\Sigma\Sigma^*\)</span> to ensure that all strings of lengths 0, 1, or 3 and above are included. Now among the four possible length 2 strings, we only need to add <span class="math inline">\(00\)</span>, <span class="math inline">\(11\)</span>, and <span class="math inline">\(10\)</span>. Some of you have given minor variations of this by explicitly including everything of lengths 0, 1, and 2, which are all fine as long as you observed that you could split the problem into an infinite part which is easy to tackle because it includes all strings of lengths greater than 2, and a finite part that can be tackled explicitly (but in some cases, shortened).</p>
<h4 id="part-b-1">Part b)</h4>
<p>Strings for which the third last character is 0.</p>
<p><strong>Answer:</strong> <span class="math inline">\(\Sigma^*0\Sigma\Sigma\)</span></p>
<p>Some of you have tackled the problem by noting that the last three characters can have only finitely many variations so <span class="math inline">\(\Sigma^*000 \cup \Sigma^*001\ldots\)</span>, which is also fine.</p>
<h3 id="question-3">Question 3</h3>
<p><em>If a <strong>non</strong>-deterministic finite state automaton, <span class="math inline">\(N:=(Q, \Sigma, \delta, q_0, F)\)</span> with <strong>at most two states</strong> recognizes a language <span class="math inline">\(L\)</span>, is it necessary that <span class="math inline">\(N':=(Q, \Sigma, \delta, q_0, F^c)\)</span> must recognize <span class="math inline">\(L^c\)</span>? If you think it is </em>always* true, then explain why, otherwise, give an explicit example of an <span class="math inline">\(N\)</span> and a string which is either accepted by both <span class="math inline">\(N\)</span> and <span class="math inline">\(N'\)</span> or rejected by both.*</p>
<p>This need not be true; it is only true for a deterministic finite state automaton. Any non-deterministic finite state automaton that has no looping arrows can only recognize a finite language. Even after flipping the accept and non-accept states, it will have to accept another <em>finite</em> language which cannot possibly exhaust the complement of a finite language because <span class="math inline">\(\Sigma^*\)</span> is infinite. From this is it is straightforward to construct an example and there are many possibilities. In fact, it is quite easy to come up with examples; almost any truly non-deterministic one with the possibility of dying out would have worked.</p>
<h3 id="question-4">Question 4</h3>
<p><em>Consider the context free grammars <span class="math inline">\(G_1=(V_1, \Sigma_1, R_1, S_1)\)</span> and <span class="math inline">\(G_2=(V_2, \Sigma_2, R_2, S_2)\)</span> generating <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span>, respectively.</em></p>
<h5 id="part-a-2">Part a)</h5>
<p><em>How will you define a context free grammar <span class="math inline">\(G = (V, \Sigma, R, S)\)</span> that recognizes <span class="math inline">\(L_1\cup L_2\)</span>?</em> The new rules should be <span class="math inline">\(R_1\cup R_2 \cup \{S \to S_1 \ |\ S_2\}\)</span>, where <span class="math inline">\(S\)</span> is a <em>new</em> variable. We need a <em>new</em> start state <span class="math inline">\(S\)</span> and the rule, <span class="math inline">\(S \to S_1 \ |\ S_2\)</span>. If one chooses <span class="math inline">\(S_1\)</span> during the deduction, then one can generate all the strings in the first language, and similarly, if one chooses <span class="math inline">\(S_2\)</span>, then one can generate all the strings in the second language. You therefore also need the original rules <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>.</p>
<p>Some of you combined each rule from <span class="math inline">\(R_1\)</span> with a rule from <span class="math inline">\(R_2\)</span> by using <span class="math inline">\(|\)</span>. This will include all strings in the union of the two languages but will also include many more that are not intended (try to think of an example!).</p>
<p><strong>IMPORTANT</strong>: <span class="math inline">\(S = S_1 \cup S_2\)</span> is a completely nonsensical expression! <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> are not sets; taking their union makes no sense! Similalry, wrting <span class="math inline">\(A_1 \to B_1 \cup B_2\)</span> is completely meaningless.</p>
<h4 id="part-b-2">Part b)</h4>
<p><em>How will you define a context free grammar <span class="math inline">\(G = (V, \Sigma, R, S)\)</span> that recognizes <span class="math inline">\(L_1 \circ L_2\)</span>?</em></p>
<p>The new rules can be <span class="math inline">\(R_1\cup R_2 \cup \{S \to S_1 S_2\}\)</span>. The new start state triggers the generation of two blocks of strings, where the first one is in <span class="math inline">\(L_1\)</span> and the second one is in <span class="math inline">\(L_2\)</span>.</p>
<p>Once again, <span class="math inline">\(R_1\circ R_2\)</span> is complete nonsense. You can concatenate strings, not rules!</p>
<h4 id="part-c-1">Part c)</h4>
<p><em>How will you define a context free grammar <span class="math inline">\(G = (V, \Sigma, R, S)\)</span> that recognizes <span class="math inline">\(L_1^*\)</span>?</em></p>
<p>The new rules can be <span class="math inline">\(R_1 \cup \{S_1\to S_1S_1 \ |\ \epsilon\}\)</span>. <span class="math inline">\(L^*\)</span> contains strings of the form <span class="math inline">\(w_1w_2\ldots w_n\)</span>. The rule <span class="math inline">\(S_1 \to S_1S_1\)</span> allows the start variable to replicate itself the required number of times, say <span class="math inline">\(n\)</span> times. So we can derive <span class="math inline">\(S_1S_1 \ldots S_1\)</span>. Now each of these <span class="math inline">\(S_1\)</span> can be replaced eventually by a string in <span class="math inline">\(L\)</span> using the previous rules.</p>
</section>
</article>
]]></summary>
</entry>
<entry>
    <title>The Pumping Lemma</title>
    <link href="http://blog.shane/posts/2020-01-29-pumping-lemma.html" />
    <id>http://blog.shane/posts/2020-01-29-pumping-lemma.html</id>
    <published>2020-01-29T00:00:00Z</published>
    <updated>2020-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
<header>
<h1>The Pumping Lemma</h1>
<p class="date"><strong>29 January, 2020</strong></p>
</header>

<section>
<p>If you suspect that it is impossible to build a finite state automaton to recognize a certain language, the pumping lemma <em>may</em> help you to prove it rigorously. However, it is important to understand the statement of the pumping lemma very precisely to use it correctly.</p>
<h2 id="an-example">An Example</h2>
<p>Consider the language, <span class="math inline">\(L\)</span>, consisting of precisely those strings over the alphabet <span class="math inline">\(\{0, 1\}\)</span> such that the number of 0s exceed the number of 1s. You suspect that any machine that attempts to recognize the language will have to “remember” the number of 0s and 1s as it is reading the input, and therefore cannot handle it with finite states. However, we need a rigorous proof.</p>
<h2 id="the-main-observation">The main observation</h2>
<p>An automaton works by reading the string one character at a time and depending on the character and its state at the time of reading the character, shifts to a new state. However, an automaton can have only finitely many states, say <span class="math inline">\(N\)</span> states. By the pigeon-hole principle, by the time it reads <span class="math inline">\(N\)</span> characters, it has been it at least one of these states more than once. For example, if the input was <span class="math inline">\(1^N0^{N+1}\)</span>, even before it starts reading the 0s, it has already repeated a state because the 1s are more than <span class="math inline">\(N\)</span>.</p>
<p>Let us look at this more closely: The machine began at the initial state, <span class="math inline">\(q_0\)</span>, but after reading, say <span class="math inline">\(l\)</span>, 1s it ended up in some state <span class="math inline">\(q_r\)</span> which it came back to after reading some more 1s, say <span class="math inline">\(m\)</span> of them. The rest of the string, containing the remaining 1s (<span class="math inline">\(N-l-m\)</span> of them) and the <span class="math inline">\(N+1\)</span> 0s that follow, takes this <span class="math inline">\(q_r\)</span> to a final state. Since <span class="math inline">\(1^N0^{N+1}\)</span> belongs to our language, having more 0s than 1s, the final state must be an accept state for the automaton to recognize this string. To summarize:</p>
<ol type="1">
<li>The machine first read <span class="math inline">\(1^l\)</span> and that took it from state <span class="math inline">\(q_0\)</span> to <span class="math inline">\(q_r\)</span>.</li>
<li>The machine then read <span class="math inline">\(1^m\)</span> which took it from state <span class="math inline">\(q_r\)</span> back again to <span class="math inline">\(q_r\)</span>.</li>
<li>The machine finally read <span class="math inline">\(1^{N-l-m} 0^{N+1}\)</span> which took it from state <span class="math inline">\(q_r\)</span> to an accept state.</li>
</ol>
<p>We do not know what <span class="math inline">\(l\)</span> and <span class="math inline">\(m\)</span> are besides the fact that <span class="math inline">\(l+m \leq N\)</span>, but that is all the information we will need.</p>
<p>The main observation is this: after it read the <span class="math inline">\(1^l\)</span> chunk, if I repeatedly fed the machine the chunk <span class="math inline">\(1^m\)</span> over and over again, it would keep coming back to the same state <span class="math inline">\(q_r\)</span>. The last chunk, <span class="math inline">\(1^{N-l-m} 0^{N+1}\)</span>, always takes <span class="math inline">\(q_r\)</span> to an accept state, so such a machine is forced to also accept strings of the form <span class="math inline">\(1^l (1^m)^i 1^{N-l-m} 0^{N+1}\)</span> for <em>any</em> <span class="math inline">\(i\)</span>. However, since the part being repeated here consists of only 1s and <span class="math inline">\(N\)</span> is fixed throughout, eventually for some large <span class="math inline">\(i\)</span>, the number of 1s will exceed the number of 0s and result in strings that should not be in our language.</p>
<p>To summarize: if we assumed that an automaton exists to recognize the language, then it must recognize the string <span class="math inline">\(1^N0^{N+1}\)</span> too where, <span class="math inline">\(N\)</span> is the number of states. The above reasonging then shows us that it must accept certain modifications of this string, many of which do not belong to the language. So no automaton can be built to accept precisely those strings that are in our language and reject the rest.</p>
<p>Note how important it was that we chose a string in our language for which the 1s came first and the number of 1s itself exceeded the number of states. That is what guaranteed that the repeated part had only 1s. Had we merely ensured that the entire string was bigger than <span class="math inline">\(N\)</span>, the pumping lemma can promise nothing about the substring responsible for repeating the state. We have to consider the possibility that that substring has only 0s, in which case repeating that chunk will result in strings which are in the language anyway so even though the automaton is forced to accept them, there is no contradiction.</p>
<p>This reasoning generalizes and the generalization is abstracted out in the pumping lemma.</p>
<h2 id="the-statement-of-the-pumping-lemma">The statement of the pumping lemma</h2>
<p><strong>Lemma:</strong> If a language can be recognized by a finite state automaton, then there is some number <span class="math inline">\(N\)</span> (called the pumping length) so that if there is a string <span class="math inline">\(w\)</span> in the language whose length exceeds <span class="math inline">\(N\)</span>, then it is possible to view <span class="math inline">\(w\)</span> as a concatenation of three substrings, <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span>, i.e. <span class="math inline">\(w = x y z\)</span>, so that</p>
<ol type="1">
<li>The middle part, <span class="math inline">\(y\)</span> is not empty (otherwise the lemma would be useless!)</li>
<li><span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are within the first <span class="math inline">\(N\)</span> characters of the string (i.e. <span class="math inline">\(|xy|\leq N\)</span>) (this is the only guarantee the lemma provides about where the break up occurs)</li>
<li>the language must also contain the modified strings <span class="math inline">\(xy^i z\)</span> for all <span class="math inline">\(i=0\ldots\)</span> (because the automaton is forced to accept them too).</li>
</ol>
<h2 id="be-careful">Be careful!</h2>
<p>You apply the lemma by making a clever choice of <span class="math inline">\(w\)</span>’s. However, since you have to account for every possible automaton, you have to be careful that you</p>
<ol type="1">
<li><em>Make no assumptions on the pumping length <span class="math inline">\(N\)</span></em>. You have to account for the possibility that <span class="math inline">\(N\)</span> could be any natural number and therefore you must consider not one <span class="math inline">\(w\)</span> but a whole sequence of them so that no matter how many states one provides an attempted automaton, there is at least one <span class="math inline">\(w\)</span> with length bigger than that number. That is why we considered <em>all</em> strings of the form <span class="math inline">\(1^N 0^{N+1}\)</span> in our example.</li>
<li><em>Make no assumptions on where the break up of <span class="math inline">\(w\)</span> into <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span> will happen</em>, except that <span class="math inline">\(xy\)</span> is within the first <span class="math inline">\(N\)</span> characters. You have to account for all the possible ways in which the break up can happen in the first <span class="math inline">\(N\)</span> characters. Nevertheless, the fact that it happens within the first <span class="math inline">\(N\)</span> characters can be very useful. In our example, we ensured that not only was the string bigger than <span class="math inline">\(N\)</span>, but the first part containing only 1s was itself bigger than <span class="math inline">\(N\)</span>. This helped us to guarantee that <span class="math inline">\(y\)</span> contained only 1s so that when we repeated <span class="math inline">\(y\)</span> we were increasing the number of 1s while keeping the number of 0s fixed. We could make no assumptions on the number of 1s in <span class="math inline">\(y\)</span>, but luckily we did not need to. All that mattered was that <span class="math inline">\(y\)</span> contained only 1s.</li>
</ol>
<h2 id="applying-the-pumping-lemma">Applying the pumping lemma</h2>
<p>If you suspect that language cannot be recognized by a finite state automation, consider a certain collection of strings from your language that have a wisely chosen form so that:</p>
<ol type="1">
<li>For each <span class="math inline">\(N\)</span> there is a string from this collection that has length more than N.</li>
<li>You should be able to demonstrate that for <em>each</em> of the possible ways of breaking up the string as <span class="math inline">\(xyz\)</span> so that <span class="math inline">\(xy\)</span> is within the first <span class="math inline">\(N\)</span> characters, <span class="math inline">\(xy^iz\)</span> does not belong to your language for at least some <span class="math inline">\(i\)</span>. So your argument must be general and cannot make any assumptions on <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span> other than the fact that <span class="math inline">\(|xy|\leq N\)</span> if the string is viewed in the form <span class="math inline">\(xyz\)</span>.</li>
</ol>
<p>You would then have shown that no matter how many states an automaton uses, you can always find a string from your language which the automaton must accept, but it is forced to also accept certain modifications of it, some of which do not belong to the language. Therefore, it is impossible to find an automaton that accepts precisely what is in the language but also rejects everything else.</p>
<h2 id="revisiting-our-example">Revisiting our example</h2>
<p>We can now formalize the above reasoning in terms of the pumping lemma as follows:</p>
<p>If the language could be recognized by an automaton, then then let <span class="math inline">\(N\)</span> denote the pumping length. The string <span class="math inline">\(1^N0^{N+1}\)</span> belongs to our language because it has more 0s than 1s. The pumping lemma guarantees that it can be written in the form <span class="math inline">\(xyz\)</span> so that <span class="math inline">\(y\)</span> is non-empty and lies within the first <span class="math inline">\(N\)</span> characters and <span class="math inline">\(xy^iz\)</span> must also belong to the language for each and every natural number <span class="math inline">\(i\)</span>. Since <span class="math inline">\(y\)</span> lies within the first <span class="math inline">\(N\)</span> characters, it involves only 1s and all the 0s lie within <span class="math inline">\(z\)</span>. Therefore, <span class="math inline">\(xy^iz\)</span> will have much more 1s than 0s for large enough <span class="math inline">\(i\)</span>. The pumping lemma says that even such strings must belong to our language, which is a contradiction. Therefore, it is impossible to design a finite state automaton that will recognize our language.</p>
</section>
</article>
]]></summary>
</entry>
<entry>
    <title>Boolean operator precedence</title>
    <link href="http://blog.shane/posts/2020-01-15-operator-precedence.html" />
    <id>http://blog.shane/posts/2020-01-15-operator-precedence.html</id>
    <published>2020-01-15T00:00:00Z</published>
    <updated>2020-01-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
<header>
<h1>Boolean operator precedence</h1>
<p class="date"><strong>15 January, 2020</strong></p>
</header>

<section>
<p>Since some of you requested, here is the order in which boolean operators are given precedence:</p>
<ol type="1">
<li><span class="math inline">\(\neg\)</span></li>
<li><span class="math inline">\(\land\)</span></li>
<li><span class="math inline">\(\lor\)</span></li>
<li><span class="math inline">\(\Rightarrow\)</span>, <span class="math inline">\(\Leftrightarrow\)</span></li>
</ol>
<p>The convention allows us to drop parentheses in many cases, even if they involve different types of operators, to make the expressions more readable.</p>
<p>Therefore, in the expression, <span class="math inline">\(\neg P \land Q \lor R \Leftrightarrow S \land T\)</span>, the parentheses are implied and the expression means, <span class="math inline">\(((\neg P \land Q) \lor R) \Leftrightarrow (S \land T)\)</span>. On the other hand, <span class="math inline">\(\neg P \land (Q \lor R) \Leftrightarrow S \land T\)</span> is a different expression and the parenthesis is essential because despite <span class="math inline">\(\lor\)</span> having a lower precedence than <span class="math inline">\(\land\)</span>, we are evaluating <span class="math inline">\(Q \lor R\)</span> <em>before</em> combining it with <span class="math inline">\(\neg P\)</span> using <span class="math inline">\(\land\)</span>.</p>
</section>
</article>
]]></summary>
</entry>

</feed>
